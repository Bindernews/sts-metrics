// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.17.0
// source: db_add.sql

package orm

import (
	"context"
	"database/sql"
)

type AddBossRelicsParams struct {
	RunID     int32
	NotPicked []int32
	Picked    int32
}

type AddCampfireParams struct {
	RunID int32
	Data  sql.NullInt32
	Floor int32
	Key   int32
}

type AddCardChoiceParams struct {
	RunID     int32
	Floor     int32
	NotPicked []int32
	Picked    int32
}

type AddDamageTakenParams struct {
	RunID   int32
	Enemies int32
	Floor   int32
	Turns   int32
}

type AddEventChoicesParams struct {
	RunID             int32
	DamageDelta       int32
	EventNameID       int32
	Floor             int32
	GoldDelta         int32
	MaxHpDelta        int32
	PlayerChoiceID    int32
	RelicsObtainedIds []int32
}

const addFlag = `-- name: AddFlag :exec
INSERT INTO RunFlags (run_id, flag) VALUES ($1, $2)
`

type AddFlagParams struct {
	RunID int32
	Flag  FlagKind
}

func (q *Queries) AddFlag(ctx context.Context, arg AddFlagParams) error {
	_, err := q.db.Exec(ctx, addFlag, arg.RunID, arg.Flag)
	return err
}

type AddMasterDeckParams struct {
	RunID    int32
	CardID   int32
	Count    int16
	Upgrades int16
}

type AddPerFloorParams struct {
	RunID     int32
	Floor     int16
	Gold      int32
	CurrentHp int32
	MaxHp     int32
}

type AddPotionObtainParams struct {
	RunID int32
	Floor int32
	Key   int32
}

type AddRelicObtainParams struct {
	RunID int32
	Floor int32
	Key   int32
}

const addRunRaw = `-- name: AddRunRaw :one
INSERT INTO RunsData
    (ascension_level, campfire_rested, campfire_upgraded, choose_seed, circlet_count,
     floor_reached, gold, items_purchased_floors, items_purged_floors, local_time,
     path_per_floor, path_taken, play_id, player_experience, playtime, potions_floor_spawned,
     potions_floor_usage, purchased_purges, score, seed_played, seed_source_timestamp,
     "timestamp", victory, win_rate)
VALUES (
    $1,$2,$3,$4,$5,$6,$7,$8,$9,$10,$11,$12,$13,$14,$15,$16,$17,$18,$19,$20,$21,$22,$23,$24
)
RETURNING RunsData.id
`

type AddRunRawParams struct {
	AscensionLevel       int32
	CampfireRested       sql.NullInt32
	CampfireUpgraded     sql.NullInt32
	ChooseSeed           bool
	CircletCount         sql.NullInt32
	FloorReached         int32
	Gold                 int32
	ItemsPurchasedFloors []int32
	ItemsPurgedFloors    []int32
	LocalTime            string
	PathPerFloor         string
	PathTaken            string
	PlayID               string
	PlayerExperience     int32
	Playtime             int32
	PotionsFloorSpawned  []int32
	PotionsFloorUsage    []int32
	PurchasedPurges      int32
	Score                int32
	SeedPlayed           string
	SeedSourceTimestamp  sql.NullInt32
	Timestamp            sql.NullTime
	Victory              bool
	WinRate              float64
}

func (q *Queries) AddRunRaw(ctx context.Context, arg AddRunRawParams) (int32, error) {
	row := q.db.QueryRow(ctx, addRunRaw,
		arg.AscensionLevel,
		arg.CampfireRested,
		arg.CampfireUpgraded,
		arg.ChooseSeed,
		arg.CircletCount,
		arg.FloorReached,
		arg.Gold,
		arg.ItemsPurchasedFloors,
		arg.ItemsPurgedFloors,
		arg.LocalTime,
		arg.PathPerFloor,
		arg.PathTaken,
		arg.PlayID,
		arg.PlayerExperience,
		arg.Playtime,
		arg.PotionsFloorSpawned,
		arg.PotionsFloorUsage,
		arg.PurchasedPurges,
		arg.Score,
		arg.SeedPlayed,
		arg.SeedSourceTimestamp,
		arg.Timestamp,
		arg.Victory,
		arg.WinRate,
	)
	var id int32
	err := row.Scan(&id)
	return id, err
}

const addRunText = `-- name: AddRunText :exec
UPDATE RunsData SET
    build_version = $2,
    character_chosen = $3,
    items_purchased_ids = $4,
    items_purged_ids = $5,
    killed_by = $6,
    neow_bonus_id = $7,
    neow_cost_id = $8
WHERE
    id = $1
`

type AddRunTextParams struct {
	ID                int32
	BuildVersion      int32
	CharacterChosen   int32
	ItemsPurchasedIds []int32
	ItemsPurgedIds    []int32
	KilledBy          int32
	NeowBonusID       int32
	NeowCostID        int32
}

func (q *Queries) AddRunText(ctx context.Context, arg AddRunTextParams) error {
	_, err := q.db.Exec(ctx, addRunText,
		arg.ID,
		arg.BuildVersion,
		arg.CharacterChosen,
		arg.ItemsPurchasedIds,
		arg.ItemsPurgedIds,
		arg.KilledBy,
		arg.NeowBonusID,
		arg.NeowCostID,
	)
	return err
}

const doesRunExist = `-- name: DoesRunExist :one
SELECT count(id)::boolean FROM RunsData R WHERE R.play_id = $1
`

func (q *Queries) DoesRunExist(ctx context.Context, playID string) (bool, error) {
	row := q.db.QueryRow(ctx, doesRunExist, playID)
	var column_1 bool
	err := row.Scan(&column_1)
	return column_1, err
}

const getCampfires = `-- name: GetCampfires :many
SELECT CC.id, CC.data, CC.floor, StrCache.str as "key" FROM CampfireChoice CC
    LEFT JOIN StrCache ON CC.key = StrCache.id
    WHERE CC.id = $1
    ORDER BY floor
`

type GetCampfiresRow struct {
	ID    int32
	Data  sql.NullInt32
	Floor int32
	Key   sql.NullString
}

func (q *Queries) GetCampfires(ctx context.Context, id int32) ([]GetCampfiresRow, error) {
	rows, err := q.db.Query(ctx, getCampfires, id)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetCampfiresRow
	for rows.Next() {
		var i GetCampfiresRow
		if err := rows.Scan(
			&i.ID,
			&i.Data,
			&i.Floor,
			&i.Key,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getRun = `-- name: GetRun :one
SELECT id, ascension_level, build_version, campfire_rested, campfire_upgraded, character_chosen, choose_seed, circlet_count, floor_reached, gold, items_purchased_floors, items_purchased_ids, items_purged_floors, items_purged_ids, killed_by, local_time, neow_bonus_id, neow_cost_id, path_per_floor, path_taken, play_id, player_experience, playtime, potions_floor_spawned, potions_floor_usage, purchased_purges, score, seed_played, seed_source_timestamp, timestamp, victory, win_rate FROM RunsData WHERE id = $1 LIMIT 1
`

func (q *Queries) GetRun(ctx context.Context, id int32) (Runsdatum, error) {
	row := q.db.QueryRow(ctx, getRun, id)
	var i Runsdatum
	err := row.Scan(
		&i.ID,
		&i.AscensionLevel,
		&i.BuildVersion,
		&i.CampfireRested,
		&i.CampfireUpgraded,
		&i.CharacterChosen,
		&i.ChooseSeed,
		&i.CircletCount,
		&i.FloorReached,
		&i.Gold,
		&i.ItemsPurchasedFloors,
		&i.ItemsPurchasedIds,
		&i.ItemsPurgedFloors,
		&i.ItemsPurgedIds,
		&i.KilledBy,
		&i.LocalTime,
		&i.NeowBonusID,
		&i.NeowCostID,
		&i.PathPerFloor,
		&i.PathTaken,
		&i.PlayID,
		&i.PlayerExperience,
		&i.Playtime,
		&i.PotionsFloorSpawned,
		&i.PotionsFloorUsage,
		&i.PurchasedPurges,
		&i.Score,
		&i.SeedPlayed,
		&i.SeedSourceTimestamp,
		&i.Timestamp,
		&i.Victory,
		&i.WinRate,
	)
	return i, err
}

const getStr = `-- name: GetStr :one
SELECT id FROM StrCache WHERE str = $1
`

func (q *Queries) GetStr(ctx context.Context, str string) (int32, error) {
	row := q.db.QueryRow(ctx, getStr, str)
	var id int32
	err := row.Scan(&id)
	return id, err
}

const strCacheAdd = `-- name: StrCacheAdd :exec
SELECT str_cache_add($1::text[])
`

func (q *Queries) StrCacheAdd(ctx context.Context, dollar_1 []string) error {
	_, err := q.db.Exec(ctx, strCacheAdd, dollar_1)
	return err
}

const strCacheToId = `-- name: StrCacheToId :many
SELECT str_cache_to_id($1::text[])
`

func (q *Queries) StrCacheToId(ctx context.Context, dollar_1 []string) ([]int32, error) {
	rows, err := q.db.Query(ctx, strCacheToId, dollar_1)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []int32
	for rows.Next() {
		var str_cache_to_id int32
		if err := rows.Scan(&str_cache_to_id); err != nil {
			return nil, err
		}
		items = append(items, str_cache_to_id)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
