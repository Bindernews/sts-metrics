// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.16.0
// source: stats.sql

package orm

import (
	"context"
)

const statsGetCharRuns = `-- name: StatsGetCharRuns :many
SELECT R.id FROM RunsData R
LEFT JOIN strcache s on R.character_chosen = s.id
WHERE s.str = $1
`

func (q *Queries) StatsGetCharRuns(ctx context.Context, str string) ([]int32, error) {
	rows, err := q.db.Query(ctx, statsGetCharRuns, str)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []int32
	for rows.Next() {
		var id int32
		if err := rows.Scan(&id); err != nil {
			return nil, err
		}
		items = append(items, id)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const statsGetOverall = `-- name: StatsGetOverall :many
WITH
    c_runs AS (SELECT id, ascension_level, build_version, campfire_rested, campfire_upgraded, character_chosen, choose_seed, circlet_count, current_hp_per_floor, floor_reached, gold, gold_per_floor, is_beta, is_daily, is_endless, is_prod, is_trial, items_purchased_floors, items_purchased_ids, items_purged_floors, items_purged_ids, killed_by, local_time, master_deck, max_hp_per_floor, neow_bonus, neow_cost, path_per_floor, path_taken, play_id, player_experience, playtime, potions_floor_spawned, potions_floor_usage, purchased_purges, score, seed_played, seed_source_timestamp, timestamp, victory, win_rate FROM RunsData WHERE character_chosen = $1)
SELECT 'runs', count(id) FROM c_runs
UNION SELECT 'avg_win_rate', avg(win_rate) FROM c_runs
UNION SELECT 'avg_cards', avg(array_length(master_deck, 1)) FROM c_runs
`

type StatsGetOverallRow struct {
	Column1 interface{}
	Count   int64
}

func (q *Queries) StatsGetOverall(ctx context.Context, characterChosen int32) ([]StatsGetOverallRow, error) {
	rows, err := q.db.Query(ctx, statsGetOverall, characterChosen)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []StatsGetOverallRow
	for rows.Next() {
		var i StatsGetOverallRow
		if err := rows.Scan(&i.Column1, &i.Count); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
