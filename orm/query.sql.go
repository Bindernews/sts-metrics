// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.16.0
// source: query.sql

package orm

import (
	"context"
	"database/sql"
)

const addCampfire = `-- name: AddCampfire :one
INSERT INTO CampfireChoice (run_id, cdata, floor, "key")
    VALUES ($1, $2, $3, (SELECT add_str($4)))
    RETURNING CampfireChoice.id
`

type AddCampfireParams struct {
	RunID int32
	Cdata sql.NullString
	Floor int32
	Ckey  string
}

func (q *Queries) AddCampfire(ctx context.Context, arg AddCampfireParams) (int32, error) {
	row := q.db.QueryRow(ctx, addCampfire,
		arg.RunID,
		arg.Cdata,
		arg.Floor,
		arg.Ckey,
	)
	var id int32
	err := row.Scan(&id)
	return id, err
}

const addCardChoice = `-- name: AddCardChoice :one
INSERT INTO CardChoices (run_id, floor, not_picked, picked)
    VALUES ($1, $2, (SELECT add_str_many($3::text[])), (SELECT add_str($4)))
    RETURNING CardChoices.id
`

type AddCardChoiceParams struct {
	RunID     int32
	Floor     int32
	NotPicked []string
	Picked    string
}

func (q *Queries) AddCardChoice(ctx context.Context, arg AddCardChoiceParams) (int32, error) {
	row := q.db.QueryRow(ctx, addCardChoice,
		arg.RunID,
		arg.Floor,
		arg.NotPicked,
		arg.Picked,
	)
	var id int32
	err := row.Scan(&id)
	return id, err
}

const addDamageTaken = `-- name: AddDamageTaken :one
INSERT INTO DamageTaken (run_id, enemies, floor, turns)
    VALUES ($1, (SELECT add_str($4)), $2, $3)
    RETURNING DamageTaken.id
`

type AddDamageTakenParams struct {
	RunID   int32
	Floor   int32
	Turns   int32
	Enemies string
}

func (q *Queries) AddDamageTaken(ctx context.Context, arg AddDamageTakenParams) (int32, error) {
	row := q.db.QueryRow(ctx, addDamageTaken,
		arg.RunID,
		arg.Floor,
		arg.Turns,
		arg.Enemies,
	)
	var id int32
	err := row.Scan(&id)
	return id, err
}

const addRelics = `-- name: AddRelics :exec
INSERT INTO RelicObtains (run_id, floor, "key")
    VALUES ($1, (SELECT unnset($2::int[])), (SELECT add_str_many($3::text[])))
`

type AddRelicsParams struct {
	RunID  sql.NullInt32
	Floors []int32
	Keys   []string
}

func (q *Queries) AddRelics(ctx context.Context, arg AddRelicsParams) error {
	_, err := q.db.Exec(ctx, addRelics, arg.RunID, arg.Floors, arg.Keys)
	return err
}

const addRun = `-- name: AddRun :one
WITH
    build_version AS (SELECT add_str($2)),
    character_chosen AS (SELECT add_str($5)),
    items_purchased AS (SELECT add_str_many($18::text[])),
    items_purged AS (SELECT add_str_many($20::text[])),
    killed_by_id AS (SELECT add_str($21))
INSERT INTO Runs (
    ascension_level,
    build_version,
    campfire_rested,
    campfire_upgraded,
    character_chosen,
    choose_seed,
    circlet_count,
    current_hp_per_floor,
    floor_reached,
    gold,
    gold_per_floor,
    is_beta,
    is_daily,
    is_endless,
    is_prod,
    is_trial,
    items_purchased_floors,
    items_purchased_ids,
    items_purged_floors,
    items_purged_ids,
    killed_by,
    local_time,
    max_hp_per_floor,
    neow_bonus,
    neow_cost, -- 25
    -- TODO path per floor,
    -- TODO path taken,
    play_id,
    player_experience,
    playtime,
    potions_floor_spawned,
    potions_floor_usage, -- 30
    purchased_purges,
    score,
    seed_played,
    seed_source_timestamp,
    ctimestamp, -- 35
    victory,
    win_rate
) VALUES (
    $1, build_version, $3, $4, character_chosen,
    $6, $7, $8, $9, $10,
    $11, $12, $13, $14, $15,
    $16, $17, items_purchased, $19, items_purged,
    killed_by_id, $22, $23, $24, $25,
    $26, $27, $28, $29, $30,
    $31, $32, $33, $34, $35,
    $36, $37
)
RETURNING Runs.id
`

type AddRunParams struct {
	AscensionLevel       int32
	S                    string
	CampfireRested       sql.NullInt32
	CampfireUpgraded     sql.NullInt32
	S_2                  string
	ChooseSeed           bool
	CircletCount         sql.NullInt32
	CurrentHpPerFloor    []int32
	FloorReached         sql.NullInt32
	Gold                 sql.NullInt32
	GoldPerFloor         []int32
	IsBeta               bool
	IsDaily              bool
	IsEndless            bool
	IsProd               bool
	IsTrial              bool
	ItemsPurchasedFloors []int32
	Column18             []string
	ItemsPurgedFloors    []int32
	Column20             []string
	S_3                  string
	LocalTime            string
	MaxHpPerFloor        []int32
	NeowBonus            string
	NeowCost             string
	PlayID               string
	PlayerExperience     sql.NullInt32
	Playtime             int32
	PotionsFloorSpawned  []int32
	PotionsFloorUsage    []int32
	PurchasedPurges      int32
	Score                sql.NullInt32
	SeedPlayed           string
	SeedSourceTimestamp  sql.NullInt32
	Ctimestamp           sql.NullTime
	Victory              sql.NullBool
	WinRate              sql.NullInt32
}

func (q *Queries) AddRun(ctx context.Context, arg AddRunParams) (int32, error) {
	row := q.db.QueryRow(ctx, addRun,
		arg.AscensionLevel,
		arg.S,
		arg.CampfireRested,
		arg.CampfireUpgraded,
		arg.S_2,
		arg.ChooseSeed,
		arg.CircletCount,
		arg.CurrentHpPerFloor,
		arg.FloorReached,
		arg.Gold,
		arg.GoldPerFloor,
		arg.IsBeta,
		arg.IsDaily,
		arg.IsEndless,
		arg.IsProd,
		arg.IsTrial,
		arg.ItemsPurchasedFloors,
		arg.Column18,
		arg.ItemsPurgedFloors,
		arg.Column20,
		arg.S_3,
		arg.LocalTime,
		arg.MaxHpPerFloor,
		arg.NeowBonus,
		arg.NeowCost,
		arg.PlayID,
		arg.PlayerExperience,
		arg.Playtime,
		arg.PotionsFloorSpawned,
		arg.PotionsFloorUsage,
		arg.PurchasedPurges,
		arg.Score,
		arg.SeedPlayed,
		arg.SeedSourceTimestamp,
		arg.Ctimestamp,
		arg.Victory,
		arg.WinRate,
	)
	var id int32
	err := row.Scan(&id)
	return id, err
}

const addStr = `-- name: AddStr :one
SELECT add_str($1)
`

func (q *Queries) AddStr(ctx context.Context, s string) (int32, error) {
	row := q.db.QueryRow(ctx, addStr, s)
	var add_str int32
	err := row.Scan(&add_str)
	return add_str, err
}

const getCampfires = `-- name: GetCampfires :many
SELECT CC.id, CC.cdata, CC.floor, StrCache.str as "key" FROM CampfireChoice AS CC
    LEFT JOIN StrCache ON CC.key = StrCache.id
    WHERE CC.id = $1
    ORDER BY floor ASC
`

type GetCampfiresRow struct {
	ID    int32
	Cdata sql.NullString
	Floor int32
	Key   sql.NullString
}

func (q *Queries) GetCampfires(ctx context.Context, id int32) ([]GetCampfiresRow, error) {
	rows, err := q.db.Query(ctx, getCampfires, id)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetCampfiresRow
	for rows.Next() {
		var i GetCampfiresRow
		if err := rows.Scan(
			&i.ID,
			&i.Cdata,
			&i.Floor,
			&i.Key,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getRun = `-- name: GetRun :one
SELECT id, ascension_level, build_version, campfire_rested, campfire_upgraded, character_chosen, choose_seed, circlet_count, current_hp_per_floor, floor_reached, gold, gold_per_floor, is_beta, is_daily, is_endless, is_prod, is_trial, items_purchased_floors, items_purchased_ids, items_purged_floors, items_purged_ids, killed_by, local_time, max_hp_per_floor, neow_bonus, neow_cost, play_id, player_experience, playtime, potions_floor_spawned, potions_floor_usage, purchased_purges, score, seed_played, seed_source_timestamp, ctimestamp, victory, win_rate FROM Runs WHERE id = $1 LIMIT 1
`

func (q *Queries) GetRun(ctx context.Context, id int32) (Run, error) {
	row := q.db.QueryRow(ctx, getRun, id)
	var i Run
	err := row.Scan(
		&i.ID,
		&i.AscensionLevel,
		&i.BuildVersion,
		&i.CampfireRested,
		&i.CampfireUpgraded,
		&i.CharacterChosen,
		&i.ChooseSeed,
		&i.CircletCount,
		&i.CurrentHpPerFloor,
		&i.FloorReached,
		&i.Gold,
		&i.GoldPerFloor,
		&i.IsBeta,
		&i.IsDaily,
		&i.IsEndless,
		&i.IsProd,
		&i.IsTrial,
		&i.ItemsPurchasedFloors,
		&i.ItemsPurchasedIds,
		&i.ItemsPurgedFloors,
		&i.ItemsPurgedIds,
		&i.KilledBy,
		&i.LocalTime,
		&i.MaxHpPerFloor,
		&i.NeowBonus,
		&i.NeowCost,
		&i.PlayID,
		&i.PlayerExperience,
		&i.Playtime,
		&i.PotionsFloorSpawned,
		&i.PotionsFloorUsage,
		&i.PurchasedPurges,
		&i.Score,
		&i.SeedPlayed,
		&i.SeedSourceTimestamp,
		&i.Ctimestamp,
		&i.Victory,
		&i.WinRate,
	)
	return i, err
}
