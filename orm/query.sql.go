// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.16.0
// source: query.sql

package orm

import (
	"context"
	"database/sql"
)

const addCampfire = `-- name: AddCampfire :one
INSERT INTO CampfireChoice (run_id, cdata, floor, "key")
    VALUES ($1, $2, $3, (SELECT add_str($4)))
    RETURNING CampfireChoice.id
`

type AddCampfireParams struct {
	RunID int32
	Cdata sql.NullString
	Floor int32
	Ckey  string
}

func (q *Queries) AddCampfire(ctx context.Context, arg AddCampfireParams) (int32, error) {
	row := q.db.QueryRow(ctx, addCampfire,
		arg.RunID,
		arg.Cdata,
		arg.Floor,
		arg.Ckey,
	)
	var id int32
	err := row.Scan(&id)
	return id, err
}

const addCardChoice = `-- name: AddCardChoice :one
INSERT INTO CardChoices (run_id, floor, not_picked, picked)
    VALUES ($1, $2, (SELECT add_str_many($3::text[])), (SELECT add_str($4)))
    RETURNING CardChoices.id
`

type AddCardChoiceParams struct {
	RunID     int32
	Floor     int32
	NotPicked []string
	Picked    string
}

func (q *Queries) AddCardChoice(ctx context.Context, arg AddCardChoiceParams) (int32, error) {
	row := q.db.QueryRow(ctx, addCardChoice,
		arg.RunID,
		arg.Floor,
		arg.NotPicked,
		arg.Picked,
	)
	var id int32
	err := row.Scan(&id)
	return id, err
}

const addDamageTaken = `-- name: AddDamageTaken :one
INSERT INTO DamageTaken (run_id, enemies, floor, turns)
    VALUES ($1, (SELECT add_str($4)), $2, $3)
    RETURNING DamageTaken.id
`

type AddDamageTakenParams struct {
	RunID   int32
	Floor   int32
	Turns   int32
	Enemies string
}

func (q *Queries) AddDamageTaken(ctx context.Context, arg AddDamageTakenParams) (int32, error) {
	row := q.db.QueryRow(ctx, addDamageTaken,
		arg.RunID,
		arg.Floor,
		arg.Turns,
		arg.Enemies,
	)
	var id int32
	err := row.Scan(&id)
	return id, err
}

const addPotionObtain = `-- name: AddPotionObtain :exec
INSERT INTO PotionObtains (run_id, floor, "key")
    VALUES ($1, $2, (SELECT add_str($3::text)))
`

type AddPotionObtainParams struct {
	RunID int32
	Floor int32
	Ckey  string
}

func (q *Queries) AddPotionObtain(ctx context.Context, arg AddPotionObtainParams) error {
	_, err := q.db.Exec(ctx, addPotionObtain, arg.RunID, arg.Floor, arg.Ckey)
	return err
}

const addRelicObtain = `-- name: AddRelicObtain :exec
INSERT INTO RelicObtains (run_id, floor, "key")
    VALUES ($1, $2, (SELECT add_str($3::text)))
`

type AddRelicObtainParams struct {
	RunID int32
	Floor int32
	Ckey  string
}

func (q *Queries) AddRelicObtain(ctx context.Context, arg AddRelicObtainParams) error {
	_, err := q.db.Exec(ctx, addRelicObtain, arg.RunID, arg.Floor, arg.Ckey)
	return err
}

const addRunRaw = `-- name: AddRunRaw :one
INSERT INTO RunsData (
    ascension_level,
    campfire_rested,
    campfire_upgraded,
    choose_seed,
    circlet_count,
    current_hp_per_floor,
    floor_reached,
    gold,
    gold_per_floor,
    is_beta, -- 10
    is_daily,
    is_endless,
    is_prod,
    is_trial,
    items_purchased_floors,
    items_purged_floors,
    local_time,
    max_hp_per_floor,
    neow_bonus,
    neow_cost, -- 20
    path_per_floor,
    path_taken,
    play_id,
    player_experience,
    playtime,
    potions_floor_spawned,
    potions_floor_usage,
    purchased_purges,
    score,
    seed_played, -- 30
    seed_source_timestamp,
    "timestamp",
    victory,
    win_rate,
    -- Default null/invalid values
    build_version, character_chosen
) VALUES (
    $1, $2, $3, $4, $5, $6, $7, $8, $9, $10,
    $11, $12, $13, $14, $15, $16, $17, $18, $19, $20,
    $21, $22, $23, $24, $25, $26, $27, $28, $29, $30,
    $31, $32, $33, $34,
    -- Default values
    1, 1
)
RETURNING RunsData.id
`

type AddRunRawParams struct {
	AscensionLevel       int32
	CampfireRested       sql.NullInt32
	CampfireUpgraded     sql.NullInt32
	ChooseSeed           bool
	CircletCount         sql.NullInt32
	CurrentHpPerFloor    []int32
	FloorReached         int32
	Gold                 int32
	GoldPerFloor         []int32
	IsBeta               bool
	IsDaily              bool
	IsEndless            bool
	IsProd               bool
	IsTrial              bool
	ItemsPurchasedFloors []int32
	ItemsPurgedFloors    []int32
	LocalTime            string
	MaxHpPerFloor        []int32
	NeowBonus            string
	NeowCost             string
	PathPerFloor         string
	PathTaken            string
	PlayID               string
	PlayerExperience     int32
	Playtime             int32
	PotionsFloorSpawned  []int32
	PotionsFloorUsage    []int32
	PurchasedPurges      int32
	Score                int32
	SeedPlayed           string
	SeedSourceTimestamp  sql.NullInt32
	Timestamp            sql.NullTime
	Victory              bool
	WinRate              int32
}

func (q *Queries) AddRunRaw(ctx context.Context, arg AddRunRawParams) (int32, error) {
	row := q.db.QueryRow(ctx, addRunRaw,
		arg.AscensionLevel,
		arg.CampfireRested,
		arg.CampfireUpgraded,
		arg.ChooseSeed,
		arg.CircletCount,
		arg.CurrentHpPerFloor,
		arg.FloorReached,
		arg.Gold,
		arg.GoldPerFloor,
		arg.IsBeta,
		arg.IsDaily,
		arg.IsEndless,
		arg.IsProd,
		arg.IsTrial,
		arg.ItemsPurchasedFloors,
		arg.ItemsPurgedFloors,
		arg.LocalTime,
		arg.MaxHpPerFloor,
		arg.NeowBonus,
		arg.NeowCost,
		arg.PathPerFloor,
		arg.PathTaken,
		arg.PlayID,
		arg.PlayerExperience,
		arg.Playtime,
		arg.PotionsFloorSpawned,
		arg.PotionsFloorUsage,
		arg.PurchasedPurges,
		arg.Score,
		arg.SeedPlayed,
		arg.SeedSourceTimestamp,
		arg.Timestamp,
		arg.Victory,
		arg.WinRate,
	)
	var id int32
	err := row.Scan(&id)
	return id, err
}

const getCampfires = `-- name: GetCampfires :many
SELECT CC.id, CC.cdata, CC.floor, StrCache.str as "key" FROM CampfireChoice AS CC
    LEFT JOIN StrCache ON CC.key = StrCache.id
    WHERE CC.id = $1
    ORDER BY floor
`

type GetCampfiresRow struct {
	ID    int32
	Cdata sql.NullString
	Floor int32
	Key   sql.NullString
}

func (q *Queries) GetCampfires(ctx context.Context, id int32) ([]GetCampfiresRow, error) {
	rows, err := q.db.Query(ctx, getCampfires, id)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetCampfiresRow
	for rows.Next() {
		var i GetCampfiresRow
		if err := rows.Scan(
			&i.ID,
			&i.Cdata,
			&i.Floor,
			&i.Key,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getRun = `-- name: GetRun :one
SELECT id, ascension_level, build_version, campfire_rested, campfire_upgraded, character_chosen, choose_seed, circlet_count, current_hp_per_floor, floor_reached, gold, gold_per_floor, is_beta, is_daily, is_endless, is_prod, is_trial, items_purchased_floors, items_purchased_ids, items_purged_floors, items_purged_ids, killed_by, local_time, max_hp_per_floor, neow_bonus, neow_cost, path_per_floor, path_taken, play_id, player_experience, playtime, potions_floor_spawned, potions_floor_usage, purchased_purges, score, seed_played, seed_source_timestamp, timestamp, victory, win_rate FROM RunsData WHERE id = $1 LIMIT 1
`

func (q *Queries) GetRun(ctx context.Context, id int32) (Runsdatum, error) {
	row := q.db.QueryRow(ctx, getRun, id)
	var i Runsdatum
	err := row.Scan(
		&i.ID,
		&i.AscensionLevel,
		&i.BuildVersion,
		&i.CampfireRested,
		&i.CampfireUpgraded,
		&i.CharacterChosen,
		&i.ChooseSeed,
		&i.CircletCount,
		&i.CurrentHpPerFloor,
		&i.FloorReached,
		&i.Gold,
		&i.GoldPerFloor,
		&i.IsBeta,
		&i.IsDaily,
		&i.IsEndless,
		&i.IsProd,
		&i.IsTrial,
		&i.ItemsPurchasedFloors,
		&i.ItemsPurchasedIds,
		&i.ItemsPurgedFloors,
		&i.ItemsPurgedIds,
		&i.KilledBy,
		&i.LocalTime,
		&i.MaxHpPerFloor,
		&i.NeowBonus,
		&i.NeowCost,
		&i.PathPerFloor,
		&i.PathTaken,
		&i.PlayID,
		&i.PlayerExperience,
		&i.Playtime,
		&i.PotionsFloorSpawned,
		&i.PotionsFloorUsage,
		&i.PurchasedPurges,
		&i.Score,
		&i.SeedPlayed,
		&i.SeedSourceTimestamp,
		&i.Timestamp,
		&i.Victory,
		&i.WinRate,
	)
	return i, err
}

const setRunText = `-- name: SetRunText :exec
UPDATE RunsText SET
    build_version = $2,
    character_chosen = $3,
    items_purchased_names = $4,
    items_purged_names = $5
WHERE
    id = $1
`

type SetRunTextParams struct {
	ID                  int32
	BuildVersion        string
	CharacterChosen     string
	ItemsPurchasedNames []string
	ItemsPurgedNames    []string
}

func (q *Queries) SetRunText(ctx context.Context, arg SetRunTextParams) error {
	_, err := q.db.Exec(ctx, setRunText,
		arg.ID,
		arg.BuildVersion,
		arg.CharacterChosen,
		arg.ItemsPurchasedNames,
		arg.ItemsPurgedNames,
	)
	return err
}
